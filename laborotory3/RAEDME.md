В этой лабораторной работе мне необходимо было разобраться, как можно реализовать параметризованный декоратор для логирования вызовов функций, и научиться использовать его в различных контекстах. Это позволило мне лучше понять, как работают декораторы, а также как можно эффективно организовать логирование данных в Python. 
### Описание задачи  

Основная цель работы заключалась в создании декоратора trace, который:

    1. По умолчанию выводит логи в консоль.
    2. Может записывать логи в JSON-файл, если указано имя файла с расширением .json.
    3. Может сохранять логи в базу данных SQLite, если передан объект типа sqlite3.Connection.

Также я реализовал утилиту showlogs, которая позволяет просматривать содержимое логов из базы данных SQLite. Это дало мне возможность не только записывать данные, но и анализировать их. 
Реализация  
### 1. Рекурсивный подход к решению задачи  

Сначала я попробовал реализовать декоратор, используя простой вывод в консоль. Это был самый базовый вариант, где я просто записывал данные о вызове функции (дата, имя функции, параметры и результат) в стандартный поток вывода (sys.stdout или sys.stderr). Это позволило мне понять основную структуру декоратора и его работу. 

Пример использования: 
python

    @trace(handle=sys.stdout)
    def example_function(x):
    return x * 2

    example_function(5)
 
 
### 2. Нерекурсивный подход  

Затем я начал экспериментировать с другими способами хранения данных. Сначала я попробовал записывать логи в JSON-файл. Это потребовало использования модуля `json` для сериализации данных. Запись в файл позволила мне сохранять логи между запусками программы. 

Пример: 
python

    @trace(handle="logger.json")
    def cube(x):
        return x**3

    cube(3)
 
 

Файл `logger.json` содержит: json

    {"datetime": "2025-04-10T12:31:40.258123", "func_name": "cube", "params": [3], "result": 27}
 
 
### 3. Использование структур данных  

Для записи логов в базу данных SQLite я использовал модуль `sqlite3`. Это потребовало создания таблицы `logtable` и записи данных в неё с помощью SQL-запросов. Я также добавил проверку на существование таблицы, чтобы избежать ошибок при повторных вызовах декоратора. 

Пример: 
python

    import sqlite3

    handle = sqlite3.connect(":memory:")
    @trace(handle=handle)
    def power_four(x):
        return x**4

    power_four(2)
 
 

Для просмотра логов используется утилита `showlogs`: 
python

    showlogs(handle)

##### Вывод: 

    (1, '2025-04-10T12:31:40.258457', 'power_four', '2', '16')

#### Изучение новых инструментов  

Не менее важным, на мой взгляд, стало изучение различных структур данных и их применения. Например: 

   1. JSON : для сериализации данных в файл.
   2. SQLite : для хранения данных в базе данных.
   3. Модуль datetime : для работы с датой и временем.
     

Это позволило мне задуматься, что разные структуры данных делают более простыми задачи с обработкой и хранением данных. 

### Полезные выводы  

1. Параметризованные функции : Реализация декоратора с параметрами (handle) позволила мне лучше понять, как можно сделать код более гибким и универсальным.
2. Работа с базами данных : Изучение SQLite помогло мне освоить основы работы с базами данных в Python.
3. Логирование : Я научился организовывать логирование данных в разных форматах, что может быть полезно для отладки и анализа работы программы.
     

### Заключение  

Для меня, как для новичка, эта лабораторная работа была очень полезной. Я вникал не только в теорию, как работают декораторы и логирование, но и пробовал применять их на практике. Также я узнал, как можно использовать различные структуры данных для решения задач. Это дало мне ценный опыт программирования на Python. 

Автор:
Петров Семён 